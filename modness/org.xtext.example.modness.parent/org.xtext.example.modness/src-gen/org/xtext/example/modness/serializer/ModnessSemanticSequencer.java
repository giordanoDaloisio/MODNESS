/*
 * generated by Xtext 2.35.0.M1
 */
package org.xtext.example.modness.serializer;

import com.google.inject.Inject;
import fairness.Dataset;
import fairness.DatasetPositiveOutcome;
import fairness.DatasetSensitiveGroup;
import fairness.DatasetSensitiveVariable;
import fairness.DatasetSensitiveVariableValue;
import fairness.DatasetSize;
import fairness.ExistingGroupFairnessMetric;
import fairness.ExistingIndividualFairnessMetric;
import fairness.ExpectedValue;
import fairness.FairnessPackage;
import fairness.GroupAnalysis;
import fairness.GroupBias;
import fairness.GroupSize;
import fairness.Logaritm;
import fairness.LogicalCondition;
import fairness.Metric;
import fairness.Operation;
import fairness.OperationValue;
import fairness.OperatorComponent;
import fairness.OtherVariable;
import fairness.PositiveOutcome;
import fairness.Probability;
import fairness.RangeOperator;
import fairness.SensitiveGroup;
import fairness.SensitiveVariable;
import fairness.SensitiveVariableValue;
import fairness.SingleOperator;
import fairness.SubLogicalCondition;
import fairness.Summation;
import fairness.VariableValue;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.modness.services.ModnessGrammarAccess;

@SuppressWarnings("all")
public class ModnessSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ModnessGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FairnessPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FairnessPackage.DATASET:
				sequence_Dataset(context, (Dataset) semanticObject); 
				return; 
			case FairnessPackage.DATASET_POSITIVE_OUTCOME:
				sequence_DatasetPositiveOutcome(context, (DatasetPositiveOutcome) semanticObject); 
				return; 
			case FairnessPackage.DATASET_SENSITIVE_GROUP:
				sequence_DatasetSensitiveGroup(context, (DatasetSensitiveGroup) semanticObject); 
				return; 
			case FairnessPackage.DATASET_SENSITIVE_VARIABLE:
				sequence_DatasetSensitiveVariable(context, (DatasetSensitiveVariable) semanticObject); 
				return; 
			case FairnessPackage.DATASET_SENSITIVE_VARIABLE_VALUE:
				sequence_DatasetSensitiveVariableValue(context, (DatasetSensitiveVariableValue) semanticObject); 
				return; 
			case FairnessPackage.DATASET_SIZE:
				sequence_DatasetSize(context, (DatasetSize) semanticObject); 
				return; 
			case FairnessPackage.EXISTING_GROUP_FAIRNESS_METRIC:
				sequence_ExistingGroupFairnessMetric(context, (ExistingGroupFairnessMetric) semanticObject); 
				return; 
			case FairnessPackage.EXISTING_INDIVIDUAL_FAIRNESS_METRIC:
				sequence_ExistingIndividualFairnessMetric(context, (ExistingIndividualFairnessMetric) semanticObject); 
				return; 
			case FairnessPackage.EXPECTED_VALUE:
				sequence_ExpectedValue(context, (ExpectedValue) semanticObject); 
				return; 
			case FairnessPackage.GROUP_ANALYSIS:
				sequence_GroupAnalysis(context, (GroupAnalysis) semanticObject); 
				return; 
			case FairnessPackage.GROUP_BIAS:
				sequence_GroupBias(context, (GroupBias) semanticObject); 
				return; 
			case FairnessPackage.GROUP_SIZE:
				sequence_GroupSize(context, (GroupSize) semanticObject); 
				return; 
			case FairnessPackage.LOGARITM:
				sequence_Logaritm(context, (Logaritm) semanticObject); 
				return; 
			case FairnessPackage.LOGICAL_CONDITION:
				sequence_LogicalCondition(context, (LogicalCondition) semanticObject); 
				return; 
			case FairnessPackage.METRIC:
				sequence_Metric(context, (Metric) semanticObject); 
				return; 
			case FairnessPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case FairnessPackage.OPERATION_VALUE:
				sequence_OperationValue(context, (OperationValue) semanticObject); 
				return; 
			case FairnessPackage.OPERATOR_COMPONENT:
				sequence_OperatorComponent(context, (OperatorComponent) semanticObject); 
				return; 
			case FairnessPackage.OTHER_VARIABLE:
				sequence_OtherVariable(context, (OtherVariable) semanticObject); 
				return; 
			case FairnessPackage.POSITIVE_OUTCOME:
				sequence_PositiveOutcome(context, (PositiveOutcome) semanticObject); 
				return; 
			case FairnessPackage.PROBABILITY:
				sequence_Probability(context, (Probability) semanticObject); 
				return; 
			case FairnessPackage.RANGE_OPERATOR:
				sequence_RangeOperator(context, (RangeOperator) semanticObject); 
				return; 
			case FairnessPackage.SENSITIVE_GROUP:
				sequence_SensitiveGroup(context, (SensitiveGroup) semanticObject); 
				return; 
			case FairnessPackage.SENSITIVE_VARIABLE:
				sequence_SensitiveVariable(context, (SensitiveVariable) semanticObject); 
				return; 
			case FairnessPackage.SENSITIVE_VARIABLE_VALUE:
				sequence_SensitiveVariableValue(context, (SensitiveVariableValue) semanticObject); 
				return; 
			case FairnessPackage.SINGLE_OPERATOR:
				sequence_SingleOperator(context, (SingleOperator) semanticObject); 
				return; 
			case FairnessPackage.SUB_LOGICAL_CONDITION:
				sequence_SubLogicalCondition(context, (SubLogicalCondition) semanticObject); 
				return; 
			case FairnessPackage.SUMMATION:
				sequence_Summation(context, (Summation) semanticObject); 
				return; 
			case FairnessPackage.VARIABLE_VALUE:
				sequence_VariableValue_Impl(context, (VariableValue) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableValue returns DatasetPositiveOutcome
	 *     DatasetPositiveOutcome returns DatasetPositiveOutcome
	 *
	 * Constraint:
	 *     (name=EString mappingPositiveOutcome=[PositiveOutcome|EString] operator=EqualityOperator relativeToDatasetSize?='relativeToDatasetSize'?)
	 * </pre>
	 */
	protected void sequence_DatasetPositiveOutcome(ISerializationContext context, DatasetPositiveOutcome semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DatasetSensitiveGroup returns DatasetSensitiveGroup
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         mappingGroup=[SensitiveGroup|EString] 
	 *         sensitiveVariables+=[DatasetSensitiveVariableValue|EString] 
	 *         sensitiveVariables+=[DatasetSensitiveVariableValue|EString]*
	 *     )
	 * </pre>
	 */
	protected void sequence_DatasetSensitiveGroup(ISerializationContext context, DatasetSensitiveGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableValue returns DatasetSensitiveVariableValue
	 *     DatasetSensitiveVariableValue returns DatasetSensitiveVariableValue
	 *
	 * Constraint:
	 *     (name=EString mappingValue=[SensitiveVariableValue|EString] operator=EqualityOperator relativeToDatasetSize?='relativeToDatasetSize'?)
	 * </pre>
	 */
	protected void sequence_DatasetSensitiveVariableValue(ISerializationContext context, DatasetSensitiveVariableValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DatasetSensitiveVariable returns DatasetSensitiveVariable
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         mappingSensitiveVariable=[SensitiveVariable|EString] 
	 *         datasetsensitivevariablevalue+=DatasetSensitiveVariableValue 
	 *         datasetsensitivevariablevalue+=DatasetSensitiveVariableValue*
	 *     )
	 * </pre>
	 */
	protected void sequence_DatasetSensitiveVariable(ISerializationContext context, DatasetSensitiveVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns DatasetSize
	 *     DatasetSize returns DatasetSize
	 *
	 * Constraint:
	 *     {DatasetSize}
	 * </pre>
	 */
	protected void sequence_DatasetSize(ISerializationContext context, DatasetSize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Dataset returns Dataset
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         groundTruthLabelName=EString? 
	 *         predictedLabelName=EString? 
	 *         filePath=EString 
	 *         (otherVariable+=OtherVariable otherVariable+=OtherVariable*)? 
	 *         positiveOutcome=DatasetPositiveOutcome 
	 *         datasetSentiveVariable+=DatasetSensitiveVariable 
	 *         datasetSentiveVariable+=DatasetSensitiveVariable*
	 *     )
	 * </pre>
	 */
	protected void sequence_Dataset(ISerializationContext context, Dataset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns ExistingGroupFairnessMetric
	 *     ExistingGroupFairnessMetric returns ExistingGroupFairnessMetric
	 *
	 * Constraint:
	 *     metric=GroupFairnessMetric
	 * </pre>
	 */
	protected void sequence_ExistingGroupFairnessMetric(ISerializationContext context, ExistingGroupFairnessMetric semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.EXISTING_GROUP_FAIRNESS_METRIC__METRIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.EXISTING_GROUP_FAIRNESS_METRIC__METRIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistingGroupFairnessMetricAccess().getMetricGroupFairnessMetricEnumRuleCall_3_0(), semanticObject.getMetric());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns ExistingIndividualFairnessMetric
	 *     ExistingIndividualFairnessMetric returns ExistingIndividualFairnessMetric
	 *
	 * Constraint:
	 *     (name=EString metric=IndividualFairnessMetric)
	 * </pre>
	 */
	protected void sequence_ExistingIndividualFairnessMetric(ISerializationContext context, ExistingIndividualFairnessMetric semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.EXISTING_INDIVIDUAL_FAIRNESS_METRIC__METRIC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.EXISTING_INDIVIDUAL_FAIRNESS_METRIC__METRIC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistingIndividualFairnessMetricAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExistingIndividualFairnessMetricAccess().getMetricIndividualFairnessMetricEnumRuleCall_4_0(), semanticObject.getMetric());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns ExpectedValue
	 *     ExpectedValue returns ExpectedValue
	 *
	 * Constraint:
	 *     (name=EString columnName=EString condition=LogicalCondition?)
	 * </pre>
	 */
	protected void sequence_ExpectedValue(ISerializationContext context, ExpectedValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GroupAnalysis returns GroupAnalysis
	 *
	 * Constraint:
	 *     (
	 *         scope=EString? 
	 *         dataset+=Dataset 
	 *         dataset+=Dataset* 
	 *         datasetUnprivilegedGroup+=DatasetSensitiveGroup 
	 *         datasetUnprivilegedGroup+=DatasetSensitiveGroup* 
	 *         datasetPrivilegedGroup+=DatasetSensitiveGroup 
	 *         datasetPrivilegedGroup+=DatasetSensitiveGroup* 
	 *         metric+=Metric 
	 *         metric+=Metric*
	 *     )
	 * </pre>
	 */
	protected void sequence_GroupAnalysis(ISerializationContext context, GroupAnalysis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     GroupBias returns GroupBias
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         domain=EString 
	 *         source+=BiasSource 
	 *         source+=BiasSource* 
	 *         sensitiveVariables+=SensitiveVariable 
	 *         sensitiveVariables+=SensitiveVariable* 
	 *         positiveOutcome=PositiveOutcome 
	 *         unprivilegedGroup+=SensitiveGroup 
	 *         unprivilegedGroup+=SensitiveGroup* 
	 *         privilegedGroup+=SensitiveGroup 
	 *         privilegedGroup+=SensitiveGroup* 
	 *         analysis+=GroupAnalysis 
	 *         analysis+=GroupAnalysis*
	 *     )
	 * </pre>
	 */
	protected void sequence_GroupBias(ISerializationContext context, GroupBias semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns GroupSize
	 *     GroupSize returns GroupSize
	 *
	 * Constraint:
	 *     (variable=[Variable|EString]? groupCondition=LogicalCondition?)
	 * </pre>
	 */
	protected void sequence_GroupSize(ISerializationContext context, GroupSize semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Logaritm
	 *     Logaritm returns Logaritm
	 *
	 * Constraint:
	 *     (name=EString operatorcomponent=OperatorComponent)
	 * </pre>
	 */
	protected void sequence_Logaritm(ISerializationContext context, Logaritm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.LOGARITM__OPERATORCOMPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.LOGARITM__OPERATORCOMPONENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogaritmAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLogaritmAccess().getOperatorcomponentOperatorComponentParserRuleCall_4_0(), semanticObject.getOperatorcomponent());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     LogicalCondition returns LogicalCondition
	 *
	 * Constraint:
	 *     (value=[VariableValue|EString]? sensitivegroup=[DatasetSensitiveGroup|EString]? sublogicalcondition=SubLogicalCondition?)
	 * </pre>
	 */
	protected void sequence_LogicalCondition(ISerializationContext context, LogicalCondition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Metric returns Metric
	 *
	 * Constraint:
	 *     (name=EString toleranceValue=EFloat function=Function operator=EqualityOperator)
	 * </pre>
	 */
	protected void sequence_Metric(ISerializationContext context, Metric semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.METRIC__TOLERANCE_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.METRIC__TOLERANCE_VALUE));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.METRIC__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.METRIC__FUNCTION));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.METRIC__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.METRIC__OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMetricAccess().getNameEStringParserRuleCall_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMetricAccess().getToleranceValueEFloatParserRuleCall_6_0(), semanticObject.getToleranceValue());
		feeder.accept(grammarAccess.getMetricAccess().getFunctionFunctionParserRuleCall_9_0(), semanticObject.getFunction());
		feeder.accept(grammarAccess.getMetricAccess().getOperatorEqualityOperatorParserRuleCall_11_0(), semanticObject.getOperator());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OperationValue returns OperationValue
	 *
	 * Constraint:
	 *     value=EFloat
	 * </pre>
	 */
	protected void sequence_OperationValue(ISerializationContext context, OperationValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.OPERATION_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.OPERATION_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOperationValueAccess().getValueEFloatParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Operation
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (equalityOperator=ArithmeticOperator leftSide=OperatorComponent rightSide=OperatorComponent)
	 * </pre>
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.OPERATION__EQUALITY_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.OPERATION__EQUALITY_OPERATOR));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.OPERATION__LEFT_SIDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.OPERATION__LEFT_SIDE));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.OPERATION__RIGHT_SIDE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.OPERATION__RIGHT_SIDE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOperationAccess().getEqualityOperatorArithmeticOperatorEnumRuleCall_3_0(), semanticObject.getEqualityOperator());
		feeder.accept(grammarAccess.getOperationAccess().getLeftSideOperatorComponentParserRuleCall_6_0(), semanticObject.getLeftSide());
		feeder.accept(grammarAccess.getOperationAccess().getRightSideOperatorComponentParserRuleCall_8_0(), semanticObject.getRightSide());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     OperatorComponent returns OperatorComponent
	 *
	 * Constraint:
	 *     (function=Function? operationvalue=OperationValue?)
	 * </pre>
	 */
	protected void sequence_OperatorComponent(ISerializationContext context, OperatorComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns OtherVariable
	 *     OtherVariable returns OtherVariable
	 *
	 * Constraint:
	 *     (name=EString (othervariablevalue+=VariableValue othervariablevalue+=VariableValue*)?)
	 * </pre>
	 */
	protected void sequence_OtherVariable(ISerializationContext context, OtherVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PositiveOutcome returns PositiveOutcome
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_PositiveOutcome(ISerializationContext context, PositiveOutcome semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.POSITIVE_OUTCOME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.POSITIVE_OUTCOME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPositiveOutcomeAccess().getNameEStringParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Probability
	 *     Probability returns Probability
	 *
	 * Constraint:
	 *     (name=EString object=LogicalCondition condition=LogicalCondition?)
	 * </pre>
	 */
	protected void sequence_Probability(ISerializationContext context, Probability semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EqualityOperator returns RangeOperator
	 *     RangeOperator returns RangeOperator
	 *
	 * Constraint:
	 *     (operator=RangeOperatorParameter lowerValue=EFloat greaterValue=EFloat)
	 * </pre>
	 */
	protected void sequence_RangeOperator(ISerializationContext context, RangeOperator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.RANGE_OPERATOR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.RANGE_OPERATOR__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.RANGE_OPERATOR__LOWER_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.RANGE_OPERATOR__LOWER_VALUE));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.RANGE_OPERATOR__GREATER_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.RANGE_OPERATOR__GREATER_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeOperatorAccess().getOperatorRangeOperatorParameterEnumRuleCall_2_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getRangeOperatorAccess().getLowerValueEFloatParserRuleCall_5_0(), semanticObject.getLowerValue());
		feeder.accept(grammarAccess.getRangeOperatorAccess().getGreaterValueEFloatParserRuleCall_8_0(), semanticObject.getGreaterValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SensitiveGroup returns SensitiveGroup
	 *
	 * Constraint:
	 *     (name=EString sensitiveValue+=[SensitiveVariableValue|EString] sensitiveValue+=[SensitiveVariableValue|EString]*)
	 * </pre>
	 */
	protected void sequence_SensitiveGroup(ISerializationContext context, SensitiveGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SensitiveVariableValue returns SensitiveVariableValue
	 *
	 * Constraint:
	 *     name=EString
	 * </pre>
	 */
	protected void sequence_SensitiveVariableValue(ISerializationContext context, SensitiveVariableValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.SENSITIVE_VARIABLE_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.SENSITIVE_VARIABLE_VALUE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSensitiveVariableValueAccess().getNameEStringParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Variable returns SensitiveVariable
	 *     SensitiveVariable returns SensitiveVariable
	 *
	 * Constraint:
	 *     (name=EString sensitiveVariableValue+=SensitiveVariableValue sensitiveVariableValue+=SensitiveVariableValue*)
	 * </pre>
	 */
	protected void sequence_SensitiveVariable(ISerializationContext context, SensitiveVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EqualityOperator returns SingleOperator
	 *     SingleOperator returns SingleOperator
	 *
	 * Constraint:
	 *     (operator=SingleOperatorParameter value=EFloat)
	 * </pre>
	 */
	protected void sequence_SingleOperator(ISerializationContext context, SingleOperator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.SINGLE_OPERATOR__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.SINGLE_OPERATOR__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.SINGLE_OPERATOR__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.SINGLE_OPERATOR__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleOperatorAccess().getOperatorSingleOperatorParameterEnumRuleCall_2_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getSingleOperatorAccess().getValueEFloatParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SubLogicalCondition returns SubLogicalCondition
	 *
	 * Constraint:
	 *     (logicalOperator=LogicalOperator logicalcondition=LogicalCondition)
	 * </pre>
	 */
	protected void sequence_SubLogicalCondition(ISerializationContext context, SubLogicalCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.SUB_LOGICAL_CONDITION__LOGICAL_OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.SUB_LOGICAL_CONDITION__LOGICAL_OPERATOR));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.SUB_LOGICAL_CONDITION__LOGICALCONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.SUB_LOGICAL_CONDITION__LOGICALCONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubLogicalConditionAccess().getLogicalOperatorLogicalOperatorEnumRuleCall_0_0(), semanticObject.getLogicalOperator());
		feeder.accept(grammarAccess.getSubLogicalConditionAccess().getLogicalconditionLogicalConditionParserRuleCall_1_0(), semanticObject.getLogicalcondition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Function returns Summation
	 *     Summation returns Summation
	 *
	 * Constraint:
	 *     (name=EString startRange=OperatorComponent endRange=OperatorComponent body=OperatorComponent)
	 * </pre>
	 */
	protected void sequence_Summation(ISerializationContext context, Summation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.SUMMATION__START_RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.SUMMATION__START_RANGE));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.SUMMATION__END_RANGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.SUMMATION__END_RANGE));
			if (transientValues.isValueTransient(semanticObject, FairnessPackage.Literals.SUMMATION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FairnessPackage.Literals.SUMMATION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSummationAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSummationAccess().getStartRangeOperatorComponentParserRuleCall_4_0(), semanticObject.getStartRange());
		feeder.accept(grammarAccess.getSummationAccess().getEndRangeOperatorComponentParserRuleCall_6_0(), semanticObject.getEndRange());
		feeder.accept(grammarAccess.getSummationAccess().getBodyOperatorComponentParserRuleCall_8_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableValue returns VariableValue
	 *     VariableValue_Impl returns VariableValue
	 *
	 * Constraint:
	 *     (operator=EqualityOperator relativeToDatasetSize?='relativeToDatasetSize'?)
	 * </pre>
	 */
	protected void sequence_VariableValue_Impl(ISerializationContext context, VariableValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
